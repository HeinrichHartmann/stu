#
# These are feature ideas that were rejected at some point.  We may of
# course revive ideas from here in the future.  When in doubt, we prefer
# to *not* support a feature, as adding a feature in the future can
# always be done without breaking compatibility, whereas removing one is
# always backward-incompatible. 
#

#
# Rules are cumulative:  you can add additional dependencies, like in
# Make.  
#

data-$NAME.txt:  build {
	./build $NAME >data-$NAME.txt
}

data-$NAME.txt:  some-other-dependency; 

# We cannot have this feature, because this will then not work:
$NAME.bib:  { ... }
a.bib:  extra dependencies ... ;
# The intention is to add dependencies to only certain files, but the
# result would be to let the second rule override the first. 

#
# Mark this target to always be an existence-only dependency 
#

!data: { mkdir data }

# Alternatively, we may introduce the rule that for directories, the
# modification date is not used.  (Not a good idea because the date may
# be useful for directories in some cases.)

#
# Support nanosecond-precision timestamps by using struct
# stat::st_mtim.* instead of struct stat::st_mtime.  Code is written in
# timestamp.hh and can be enabled via USE_MTIM, but is disabled because
# common filesystems seems to give wrong timestamps. 
#

#
# Pass name of target and dependencies as $0 and $1, $2, etc. (?).  All
# of these can be passed to the shell after the -c option, but the
# problem is that $0 is used in error messages of the shell as the
# filename, which would give weird error messages.  It would thus be
# better to pass the place of the command in $0, if the -c option would
# support something similar to the #line proprocessor directive. 
#

#
# By default, the target @main is built, regardless of position in file.
# If @main does not exist, the first target is made (must be
# unparametrized)  We can also make it an error to build the first
# target automatically and always require @main.  
#
# Reason for rejecting:  This would break the
# pattern where a file can be executed as-is, or included by another
# one. 
#

@main:  A B C;

#
# Allow flags outside of variable dependencies.  They are only allowed
# inside at the moment.  
#

A:  !$[B] { ... }

#
# Allow to combine '?' and '!'.  Reason for rejection:  This is not
# needed as it would mean the command for 'B' would never be executed,
# and 'B's existence or timestamp would also never be verified, making
# '?!B' a no-op, and likely a bug.  It may of course be useful as a
# corner case, so we may allow it in the future. 
#

A:  ?!B { ... }
